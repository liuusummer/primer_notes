# 第十三章 拷贝控制

当定义一个类时，我们显式或隐式地指定了在此类型对象拷贝、移动、赋值和销毁时做什么。

**拷贝控制操作**（copy control）:

- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值函数（move-assignement operator）
- 析构函数（destructor）

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。

拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。

析构函数定义了当此类型对象销毁时做什么

## 拷贝、赋值和销毁

最基本的操作--拷贝构造函数、拷贝赋值运算符和析构函数

### 拷贝构造函数

- 如果一个构造函数的第一个参数是**自身类类型的引用**，且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。

  ```c++
  class Foo{    
  public:
      Foo();  // 默认构造函数
      Foo(const Foo&);  // 拷贝构造函数
      // ...
  };
  ```

  - 第一个参数必须是一个引用参数。
  - 虽然可以定义接受非`const`引用的拷贝构造函数，但此参数几乎总是一个`const`的引用。
  - 通常不应该是`explicit`的，因为拷贝构造函数在几种情况下都会被隐式地使用。

- **合成的拷贝构造函数**（synthesized copy constructor）：会将参数的成员逐个拷贝到正在创建的对象中。

- **拷贝初始化**：

  - ```c++
    string dots(10,'.');  // 直接初始化
    string s(dots);   // 直接初始化
    string s2 = dots;  // 拷贝初始化
    string null_book = "9-999-99999-9";  // 拷贝初始化
    string nines = string(100,'9');  // 拷贝初始化
    ```

    当使用直接初始化时，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

    当使用拷贝初始化时，实际上要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换

  - 拷贝初始化出现场景：
    - 用`=`定义变量时。
    - 将一个对象作为实参传递给一个非引用类型的形参。
    - 从一个返回类型为非引用类型的函数返回一个对象。
    - 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。
    - 某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当初始化标准库容器或调用`insert`或`push`成员时，容器会对其元素进行拷贝初始化。与之相对，使用`emplace`成员创建的元素都进行直接初始化。
    
  - 拷贝初始化的限制：
  
    ```c++
    vector<int> v1(10);  // ok:直接初始化
    vector<int> v2 = 10; // error:接受大小参数的构造函数是explicit的
    
    void f(vector<int>); // f的参数进行拷贝初始化
    f(10); // error:不能用一个explicit的构造函数拷贝一个实参
    f(vector<int>(10)); // ok:从一个int直接构造一个临时vector
    ```
  
    直接初始化`v1`是合法的，但看起来与之等价的拷贝初始化`v2`则是错误的，因为**`vector`的接受单一参数的构造函数是`explicit`的**。
  
    同样，当传递一个实参或从函数返回一个值时，不能隐式使用一个`explicit`构造函数，如果希望使用一个`explicit`构造函数，必须显式地使用。

### 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```c++
Sales_data trans,accum;
trans = accum; // 使用Sales_data的拷贝赋值运算符
```

与拷贝函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

- **重载赋值运算符**：
  
  - 重载运算符本质上是函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为`operator=`的函数。运算符函数也有一个返回类型和一个参数列表。
  
  - 重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数。其左侧运算对象就绑定到隐式的`this`参数。对于一个二元运算符，例如赋值运算符，其右侧对象作为显式参数传递。
  
  - 拷贝赋值运算符接受一个与其所在类相同类型的参数。为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。
  
    ```c++
    class Foo{
    public:
        Foo& operator=(const Foo&);  // 赋值运算符
        // ...
    };
    ```
  
- **合成拷贝赋值运算符**：

  - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符（synthesized copy-assignment operator）。
  - 对于某些类，合成的拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非`static`成员赋予左侧运算对象的对应成员。这一工作是通过成员类型的拷贝赋值运算符完成的。对于数组类型的成员，逐个赋值数组元素。
  - 合成的拷贝赋值运算符返回一个指向其左侧运算对象的引用。

### 析构函数

- 释放对象所使用的资源，并销毁对象的非`static`数据成员。

- 析构函数是类的一个成员函数。名字由波浪号接类名构成。没有返回值，也不接受参数。析构函数不能被重载。对于一个给定类，只会有唯一一个析构函数。

  ```c++
  class Foo{
  public:
      ~Foo();  // 析构函数
      // ...
  };
  ```

- 调用时机：无论何时一个对象被销毁，就会自动调用其析构函数
  - 变量在离开其作用域时被销毁。
  - 当一个对象被销毁时，其成员被销毁。
  - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
  - 动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁。
  - 对于临时对象，当创建它的完整表达式结束时被销毁。
  
- **合成析构函数**：当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数（syntheisized destructor）。
  
  - 对于某些类，合成的析构函数被用来组织该类型对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。
  - 空函数体执行完后，**成员会被自动销毁。**
  - 注意：析构函数体本身并不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。

### 三/五法则

如上所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。一个类还可以定义一个移动构造函数和一个移动赋值运算符。

- 需要析构函数的类也需要拷贝和赋值操作。
- 需要拷贝操作的类也需要赋值操作，反之亦然--如果一个类需要拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是拷贝赋值运算符都不必然意味着也需要析构函数。

### 使用=default

- 可以通过将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本。

  ```c++
  class Sales_data{
  public:
      // 拷贝控制成员
      Sales_data() = default;
      Sales_data(const Sales_data &) = default;
      Sales_data& operator=(const Sales_data &);
      ~Sales_data() = default;
      // 其他成员定义
  };
  Sales_data& Sales_data::operator=(const Sales_data &) = default;
  ```

  - 合成的函数将隐式地声明为内联的。如果不希望合成的成员是内联函数，应该只对成员的类外定义使用`=default`。

### 阻止拷贝

- 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。

- 虽然大多数类应该定义（而且通常也的确定义了）拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值

- **定义删除的函数：**新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数（deleted function）**来阻止拷贝

  - 删除的函数：虽然声明了它们，但是不能以任何方式使用它们。

  - 在函数的参数列表后面加上`=delete`来指出希望将它定义为删除的

    ```c++
    struct NoCopy{
        NoCopy() = default;  // 使用合成的默认构造函数
        NoCopy(const NoCopy&) = delete;  // 阻止拷贝
        NoCopy& operator=(const NoCopy &) = delete;  // 阻止赋值
        ~NoCopy() = default; // 使用合成的默认析构函数
        // 其他成员
    };
    ```

- 析构函数不能是删除的成员。

- 如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。

- 老版本使用`private`声明来阻止拷贝。

## 拷贝控制和资源管理

- 类的行为可以像一个值，也可以像一个指针。
  - 行为像值：对象有自己的状态。当拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
  
    例子：对于`HasPtr`类
  
    ```c++
    class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):
        	ps(new std::string(s)),i(0){}
    private:
        std::string *ps;
        int i;
    }
    ```
  
    为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。对于`ps`指向的`string`，每个`HasPtr`都必须有自己的拷贝：
  
    注意拷贝赋值运算符：赋值运算符组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧对象拷贝数据。重要的是：这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确。如果可能，赋值运算符还应该是异常安全的--当异常发生时，能将左侧运算对象置于一个有意义的状态。
  
    本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的`string`。
  
    ```c++
    class HasPtr {
    public:
    	HasPtr(const std::string &s = std::string()) :
    		ps(new std::string(s)), i(0) {
    	}
    // 对ps指向的string,每个HasPtr对象都有自己的拷贝
    	HasPtr(const HasPtr &h):ps(new string(*h.ps)),i(h.i) {
    	}
    
    	HasPtr &operator=(const HasPtr &rhs_hp) {
    		
    		auto new_p = new std::string(*rhs_hp.ps); // 拷贝底层string
    		delete ps;   // 释放旧内存
    		ps = new_p;   // 从右侧运算对象拷贝数据到本对象
    		i = rhs_hp.i;
    		return *this;  // 返回本对象
    	}
    	~HasPtr() {
    		delete ps;
    	}
    private:
    	std::string *ps;
    	int i;
    };
    ```
  
  - 行为像指针：行为像指针的类则共享状态。拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。
  
    本例中：对于定义行为类似指针的类，需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身的值而不是它指向的`string`
  
    要注意析构函数不能单方面地释放关联的`string`，只有当最后一个指向`string`的`HasPtr`销毁时，才能释放`string`。这种情况下可以使用引用计数（reference count）
  
    ```c++
    // 定义一个使用引用计数的类
    class HasPtr {
    public:
    	// 构造函数分配新的string和新的计数器，并将计数器置为1
    	HasPtr(const std::string &s = std::string()) :
    		ps(new string(s)), i(0), use(new std::size_t(1)) {
    	}
    
    	// 拷贝构造函数拷贝所有的数据成员，并递增计数器
    	HasPtr(const HasPtr &p) :
    		ps(p.ps), i(p.i), use(p.use) {
    		++ *use;
    	}
    	HasPtr &operator=(const HasPtr &);
    	~HasPtr();
    private:
    	std::string *ps;
    	int i;
    	std::size_t *use; // 用来记录有多少个对象共享*ps的成员
    };
    ```
  
    析构函数应该递减引用计数，指出共享`string`的对象少了一个。如果计数器变为0，则析构函数释放`ps`和`use`指向的内存：
  
    ```c++
    HasPtr::~HasPtr(){
        if(--*use == 0){
            delete ps; 
            delete use;
        }
    }
    ```
  
    拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。它必须递增右侧运算对象的引用计数（即，拷贝构造函数的工作），并递减左侧运算对象的引用计数，在必要的时候释放使用的内存（即，析构函数的作用）
  
    ```c++
    HasPtr &HasPtr::operator=(const HasPtr &rhs) {
    	++ *rhs.use;   // 递增右侧运算对象的引用计数
    	if (-- *use == 0) {  // 递减本对象的引用计数
    		delete ps;     // 如果没有其他用户  释放本对象分配的成员
    		delete use;
    	}
    	ps = rhs.ps;      // 将数据从rhs拷贝到本对象
    	i = rhs.i;
    	use = rhs.use;
    	return *this;      // 返回本对象
    }
    ```
  
    

## 交换操作

- 除了定义拷贝控制成员，管理资源的类通常还定义一个名为`swap`的函数。

- 经常用于重排元素顺序的算法。

- 如果一个类定义了自己的`swap`，那么算法将使用类自定义版本。否则，算法将使用标准库定义的`swap`

  对于类值版本的`HasPtr`，希望`swap`交换指针，而不是分配`string`的新副本，即：希望这样交换两个`HasPtr`

  ```c++
  string *temp = v1.ps;  // 为v1.ps中的指针创建一个副本
  v1.ps = v2.ps;         // 将v2.ps中的指针赋予v1.ps
  v2.ps = temp;          // 将保存的v1.ps中原来的指针赋予v2.ps
  ```

  ```c++
  // 在HasPtr类上定义自己版本的swap来重载swap的默认行为
  class HasPtr{
      friend void swap(HasPtr&,HasPtr&);
      // 其他定义
  }；
  inline void swap(HasPtr& lhs,HasPtr& rhs){
      using std::swap;
      swap(lhs.ps,rhs.ps);   // 交换指针，而不是string数据
      swap(lhs.i,rhs.i);     // 交换int成员
  }
  ```

  

## 对象移动

- 很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。
- 在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。

  标准库容器、`string`和`shared_ptr`类既可以支持移动也支持拷贝。`IO`类和`unique_ptr`类可以移动但不能拷贝。

### 右值引用

- 为了支持移动操作，新标准引入一种新的引用类型---**右值引用（rvalue reference）**以支持移动操作。所谓右值引用就是必须绑定到右值的引用。通过**`&&`而不是`&`获得右值引用**。

- 右值引用一个重要的特性：只能绑定到一个将要销毁的对象。因此可以自由地将一个右值引用的资源“移动”到另一个对象中。

- 回忆：一般而来，一个左值表达式表示的是一个对象的身份；而一个右值表达式表示的是对象的值。

- 常规引用可以称之为左值引用。不能将左值引用绑定到要求转换的表达式、字面常量或者是返回右值的表达式；右值引用有着完全相反的绑定特性：可以将一个右值引用绑定到这类表达式上，但不能将右值引用直接绑定到一个左值上：

  ```c++
  int i = 42;
  int &r = i;   // ok:r引用i
  int &&rr = i;  // error:不能将一个右值引用绑定到一个左值上
  int &r2 = i*42; // error:i*42是一个右值
  const int &r3 = i*42; // ok:可以将一个const的引用绑定到一个右值上
  int &&rr2 = i*42;  // ok：将rr2绑定到乘法结果上
  ```

  - 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。可以将一个左值引用绑定到这类表达式的结果上
  - 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。不能将一个左值引用绑定到这类表达式上，但可以将一个`const`的左值引用或一个右值引用绑定到这类表达式上。

- **左值持久，右值短暂。**

  左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

- **变量是左值**：变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值。不能将一个右值引用绑定到一个右值引用类型的变量上：

  ```c++
  int &&rr1 = 42;  // ok：字面常量是右值
  int &&rr2 = rr1; // error:表达式rr1是左值
  // 变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型
  ```

**标准库move函数**：

- 定义在头文件`utility`

- 虽然不能将右值引用直接绑定到一个左值上，但可以显式地将一个左值转换为对应的右值引用类型。通过调用`move`函数来获得绑定到左值上的右值引用。

  ```c++
  int &&rr1 = 42; 
  int &&rr3 = std::move(rr1); // ok;
  ```

  `move`告诉编译器:我们有一个左值，但我希望像右值一样处理它。

  调用`move`意味着：除了对`rr1`赋值或者销毁它外，我们将不再使用它。在调用`move`之后，我们不能对移后源对象的值做任何假设。

  note：我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

- 使用`move`的代码应该使用是`std::move`而不是`move`，这样可以避免潜在的名字冲突。

### 移动构造函数和移动赋值运算符

为了让自己定义的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。

- **移动构造函数**：
  
  - 类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，不同于拷贝构造函数的是，这个引用参数是一个**右值引用**。与拷贝构造函数一样，任何额外的参数都必须有默认实参。
  
  - 为了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态：销毁它是无害的。
  
  - 例子：为`StrVec`类定义移动构造函数，实现从一个`StrVec`到另一个`StrVec`的元素移动而非拷贝：
  
    ```c++
    StrVec::StrVec(StrVec &&s) noexcept  // 移动操作不应抛出异常
        // 成员初始化器接管s中的资源
       ：elements(s.elements),first_free(s.first_free),cap(s.cap){
        // 令s进入这样的状态，对其运行析构函数是安全的
        s.elements = s.first_free = s.cap = nullptr;
    }
    ```
  
  - 与拷贝构造函数不同，移动构造函数不分配任何新内存，只是接管给定的内存。接管内存之后，将给定对象中的指针都置为`nullptr`。
  
  - 由于移动函数“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，应将此事通知标准库。
  
    一种通知标准库的方法是在构造函数中指明`noexcept`。在一个函数的参数列表后指明`noexcept`。在一个构造函数中，`noexcept`出现在参数列表和初始化列表开始的冒号之间：
  
    ```c++
    class StrVec{
    public:
        StrVec(StrVec&&) noexcept;    // 移动构造函数
        //  ....
    };
    StrVec::StrVec(StrVec&&s) noexcept : /* 成员初始化器*/ {
        // 构造函数体
    }
    ```
  
    
  
- **移动赋值运算符**：
  
  - 移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果移动赋值运算符不抛出异常，就应该把它标记为`noexcept`。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：
    
    ```c++
    StrVec& StrVec::operator=(StrVec &&rhs) noexcept{
        // 直接检测自赋值
        if(!this == &rhs){
            free();  // 释放已有元素
            elements = rhs.elements  // 从rhs接管资源
            first_free = rhs.first_free;
            cap = rhs.cap;
            // 将rhs置于可析构状态
            rhs.elements = rhs.first_free = rhs.cap = nullptr;
        }
        return *this;
    }
    ```
    
  - 与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。
  
    与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。
  
    只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非`static`数据成员都可以移动时，编译器才会为它合成移动构造函数或移动构造函数。
  
    ```c++
    // 编译器可以移动内置类型的成员
    // 如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员
    struct X{
        int i;  // 内置类型可以移动
        std::string s;  // string定义了自己的移动操作
    };
    struct hasX{
        X men;   // X有合成的移动操作
    };
    X x, x2 = std::move(x);     // 使用合成的移动构造函数
    hasX hx,hx2 = std::move(hx);  // 使用合成的移动构造函数
    ```
  
- 移动右值，拷贝左值。

  如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。

  ```c++
  StrVec v1,v2;
  v1 = v2;   // v2是左值；使用拷贝赋值
  StrVec getVec(std::istream &);  // getVec返回一个右值
  v2 = getVec(std::cin);   // getVec(cin)是一个右值；使用移动赋值
  ```

- 如果没有移动构造函数，右值也被拷贝。

  如果一个类没有移动构造函数，函数匹配规则保证该类型对象会被拷贝，即使我们试图通过调用`move`来移动它们时也是如此：

  ```c++
  class Foo{
  public:
      Foo() = default;
      Foo(const Foo&); // 拷贝构造函数
      // ...  没有移动构造函数
  };
  Foo x;
  Foo y(x);  // 拷贝构造函数：x是一个左值
  Foo z(stdx::move(x));  // 拷贝构造函数，因为未定义移动构造函数
  ```

  

- 更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。

- 移动迭代器：
  - `make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。
  
- 建议：小心地使用移动操作，以获得性能提升。

### 右值引用和成员函数

- 区分移动和拷贝的重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`。

  例如，定义了`push_back`的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有`const`左值引用。

  ```c++
  void push_back(const X&);  // 拷贝：绑定到任意类型的X
  void push_back(X&&);       // 移动：只能绑定到类型X的可修改的右值
  ```

  例：为`StrVec`类定义另一个版本的`push_back`

  ```c++
  class StrVec{
  public:
      void push_back(const std::string&);  // 拷贝元素
      void push_back(std::string&&);       // 移动元素
      //...
  };
  void StrVec::push_back(const string&s){
      chk_n_alloc();   // 确保有空间容纳新元素
      // 在first_free指向的元素中构造s的一个副本
      alloc.construct(first_free++,s);
  }
  void StrVec::push_back(string&&s){
      chk_n_alloc();   // 如果有需要的话为StrVec重新分配内存
      
      alloc.construct(first_free++,std::move(s));
  }
  
  ```

  当调用`push_back`时，实参类型决定了新元素是拷贝还是移动到容器中：

  ```c++
  StrVec vec;   // 空StrVec;
  string s = "some string or another";
  vec.push_back(s);  // 调用push_back(const string&)
  vec.push_back("done");  // 调用push_back(string&&)
  ```

  

- 右值和左值引用成员函数：

  通常在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值

  ```c++
  string s1 = "a value",s2 = "another";
  auto n = (s1+s2).find('a');
  // 在一个sting右值上调用find成员  该string右值是通过连接两个string而得到的。
  ```

  有时，可以对右值赋值

  ```c++
  s1+s2 = "hello";
  ```

  在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即`this`指向的对象）必须是一个左值。

  在非`static`成员函数的形参列表后面添加**引用限定符（reference qualifier）**可以指定`this`的左值/右值属性。引用限定符可以是`&`或者`&&`，分别表示`this`可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。

  ```c++
  class Foo{
  public:
      Foo &operator=(const Foo &) &;  // 只能向可修改的左值赋值
      // ...
  };
  Foo &Foo::operator=(const Foo&rhs)&{
      // 执行将rhs赋予本对象所需的工作
      return *this;
  }
  ```

  - 对于`&`限定的函数，只能将它用于左值；对于`&&`限定的函数，只能用于右值

    ```c++
    Foo &retFoo();  // 返回一个引用；retFoo调用是一个左值
    Foo retVal();   // 返回一个值；retVal调用是一个右值
    Foo i,j;   // i j是左值
    i = j;  // ok:i是左值
    retFoo() = j;  // ok:retFoo()返回一个左值
    retVal() = j;  // error:retVal()返回一个右值
    i = retVal();  // ok:可以将一个右值作为赋值操作的右侧运算对象
    ```

  - 一个非`static`成员函数可以同时使用`const`和引用限定符，此时引用限定符跟在`const`限定符之后。

    ```c++
    class Foo
    {
    public:
        Foo someMem() & const;      // error: const 限定符必须在前
        Foo anotherMem() const &;   // ok
    };
    ```

  - 引用限定符也可以区分成员函数的重载版本。因而可以综合引用限定符和`const`来区分一个成员函数的重载版本

    ```c++
    class Foo
    {
    public:
        Foo sorted() &&;        // 可用于可改变的右值
        Foo sorted() const &;   // 可用于任何类型的Foo
    	// ...
    private:
        vector<int> data;
    };
    
    // 本对象是右值，因此可以原址排序
    Foo Foo::sorted()&&{
        sort(data.begin(),data.end());
        return *this;
    }
    
    // 本对象是一个const或是一个左值，哪种情况下都不能对其进行原址排序
    Foo Foo::sorted() const &{
        Foo ret(*this);   // 拷贝一个副本
        sort(ret.data.begin(),ret.data.end());  // 排序副本
        return ret;       // 返回副本
    }
    ```

    编译器会根据调用`sorted`的对象的左值/右值属性来确定来使用哪个`sorted`版本：

    ```c++
    retVal().sorted();   // retVal() 是一个右值，调用 Foo::sorted() &&
    retFoo().sorted();   // retFoo() 是一个左值, 调用 Foo::sorted() const &
    ```

    - 如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。

      ```c++
      class Foo
      {
      public:
          Foo sorted() &&;
          Foo sorted() const;    // error: 必须加上引用限定符
          // Comp 是函数类型的类型别名
          // 此函数类型可以用来比较int值
          using Comp = bool(const int&, const int&);
          Foo sorted(Comp*);  // ok: 不同的参数列表
          Foo sorted(Comp*) const;  // ok: 两个版本都没有引用限定符
      };
      ```

      

