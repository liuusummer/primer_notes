# 第三章 字符串、向量和数组

## using声明
- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。

## string
- 标准库类型`string`表示可变长的字符序列。
- `#include <string>`，然后 `using std::string;`
- **string对象**：注意，不同于字符串字面值。
### 定义和初始化string对象

初始化`string`对象的方式：

| 方式 | 解释 |
| -- | -- |
| `string s1` | 默认初始化，`s1`是个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本 |
| `string s3("value")` | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本 |
| `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- 直接初始化（direct initialization）：通过括号给对象赋值。

### string对象上的操作

`string`的操作：

| 操作 | 解释 |
|-----|-----|
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中字符的个数 |
| `s[n]` | 返回`s`中第`n`个字符的引用，位置`n`从0计起 |
| `s1+s2` | 返回`s1`和`s2`连接后的结果 |
| `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2` | 同上 |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |

- string io：
    - 执行读操作`>>`：**忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止**。
    
      ```c++
      int main(){
          string s;
          cin >> s;
          cout << s << endl;
          return 0;
      }
      ```
    
      如果输入`（空格    ）Hello World!`,则输出`Hello`，输出结果中没有任何空格。
    
    - `getline`：读取一整行，**包括空白符**。`getline`函数的参数是一个输入流和一个`string`对象，函数从给定的输入流中读入内容，直到遇到换行符为止，然后将所读内容存入到`string`对象中（不存换行符）
    
      `getline`也会返回它的流参数，也能用`getline`的结果作为条件
    
      ```c++
      int main(){
          string line;
          // 每次读入一整行，直至达到文件末尾
          while(getline(cin,line)){
              cout << line << endl;   // line中不含换行符，手动加上换行符
          }
          return 0;
      }
      ```
    
- `string`的`empty`和`size`

    `empty`函数根据`string`对象是否为空返回对应的布尔值

    `s.size()`返回的是`string::size_type`类型，记住是一个**无符号**类型的值，不要和`int`混用

- `s1+s2`使用时，要保证至少一侧是string类型。

    `string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`

- **字符串字面值和string是不同的类型。**

### 处理string对象中的字符

- **ctype.h vs. cctype**：C++修改了c的标准库，名称为去掉`.h`，前面加`c`。
  
  > 如c++版本为`cctype`，c版本为`ctype.h`
  - **尽量使用c++版本的头文件**，即`cctype`

**`cctype`头文件**中定义了一组标准函数：

| 函数 | 解释 |
|-----|-----|
| `isalnum(c)` | 当`c`是字母或数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真 |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
| `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

- **基于范围的for循环（range for）**语句：遍历给定序列中的每个元素并对序列中的每个值执行某种操作

  语法形式：

  ```c++
  for(declaration:expression)  
  	statement   
  // expression部分是一个对象，用于表示一个序列
  // declaration部分负责定义一个变量，该变量负责用于访问序列中的基础元素。每次迭代，declaration部分的变量就会被初始化为expression部分的下一个元素值
  ```

   `for (auto c: str)`，

   `for (auto &c: str)`使用**引用**直接改变字符串中的字符。 （C++11）

- 下标运算符`[]` :

  输入参数为`string::size_type`类型，表示要访问的字符的位置，返回值是该位置上字符的引用。

  范围大于等于0小于`s.size()`

  给出`int`整型也会自动转化为该类型

  ```c++
  string test = "some string";
  	for (decltype(test.size()) index = 0;
  		index != test.size() && !isspace(test[index]); index++) {
  		test[index] = toupper(test[index]);
  	}
  	std::cout << test;  // 输出 SOME string
  ```

## vector
- vector是一个**容器**，也是一个类模板；

- `#include <vector>` 

  然后 `using std::vector;`

- 容器(container)：包含其他对象。

- **实例化（instantiation）** ：编译器根据模板创建类或函数的过程称为实例化(instantiation)。

- 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型。

- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。

- 因为引用不是对象，所以**不存在**包含引用的`vector`.

### 定义和初始化vector对象

初始化`vector`对象的方法

| 方法 | 解释 |
|-----|-----|
| `vector<T> v1` | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | `v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
| `vector<T> v3(n, val)` | `v3`包含了n个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | `v4`包含了n个重复地执行了值初始化的对象 |
| `vector<T> v5{a, b, c...}` | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |

- 列表初始化（C++11）

  如果提供的是初始值元素的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

  ```c++
  vector<string> v{"a", "an", "the"}; // 列表初始化
  vector<string> v("a","an","the"); // error
  ```

- 分辨列表初始值还是元素数量

  ```c++
  vector<int> v1(10);  // v1有10个元素，每个的值都是0
  vector<int> v2{10};  // v2有1个元素，值为10
  vector<int> v3(10,1); // v3有10个元素，每个值为1
  vector<int> v4{10,1}; // v4有2个元素，值分别为10，1
  ```

  如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造`vector`对象了。
  
  ```c++
  vector<string> v5{"hi"}; // 列表初始化：v5有一个元素
  vector<string> v6("hi"); // error:不能使用字符串字面值构建vector对象
  vector<string> v7{10}; // v7有10个默认初始化的元素
  vector<string> v8{10,"hi"}; // v8有10个值为"hi"的元素
  ```
  
  

### 向vector对象中添加元素

- `vector`的成员函数`v.push_back(e)` 在尾部增加元素。  `push_back`负责把一个值当成`vector`对象的尾元素“压到”`(push)`到`vector`对象的“尾端”`(back)`.

```c++
//从标准输入中读取单词，将其作为vector对象的元素存储
string word;
vector<string> text;   // 空vector对象
while(cin >> word){
    text.push_back(word); 
}
```

- 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围`for``（range for）`。

  **范围`for`语句体内不应该改变其所遍历序列的大小**

### 其他vector操作

`vector`支持的操作：

| 操作 | 解释 |
|-----|-----|
| `v.emtpy()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` | 返回`v`中元素的个数，返回值的类型是`vector<T>::size_type`类型 |
| `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
| `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2` | 同上 |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较 |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，**不能用于添加元素**。

## 迭代器iterator

- 所有标准库容器都可以使用迭代器。但是其中只有少数几种才同时支持下标运算符。严格来说，`string`对象不属于容器类型，但是`string`支持很多与容器类型类似的操作。`string`支持迭代器。
- 类似于指针类型，迭代器也提供了对对象的间接访问。
- 有效与无效之分。有效的迭代器指向某个元素或者容器中尾元素的下一个元素。其他所有情况都属于无效。

### 使用迭代器

- `vector<int>::iterator iter`。
- `auto b = v.begin();`返回指向第一个元素的迭代器。

  `auto e = v.end();`返回指向**最后一个元素的下一个**（哨兵，**尾后**,one past the end）的迭代器（off the end）。
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。
- 使用解引用符`*`访问迭代器指向的元素。
- 养成使用迭代器和`!=`的习惯（泛型编程）。
- **容器**：可以包含其他对象；但所有的对象必须类型相同。
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。
- **const_iterator**：只能读取容器内元素不能改变。
- **箭头运算符->**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`
- **谨记**：但凡是使用了**迭代器**的循环体，都**不要**向迭代器所属的容器**添加元素**。
- `c++11`引入两个新函数，`cbegin()` `cend()`,类似于`begin()` `end()`,也分别返回指示容器第一个或者最后一个元素下一个位置的迭代器。`cbegin()``cend()`返回值类型是`const_iterator`

标准容器迭代器的运算符:

| 运算符 | 解释 |
|-----|-----|
| `*iter` | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem` | 等价于`(*iter).mem` |
| `++iter` | 令`iter`指示容器中的下一个元素 |
| `--iter` | 令`iter`指示容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等 |
| `iter1 != iter2` | 判断两个迭代器是否不相等 |

### 迭代器运算(iterator arithmetic)

`vector`和`string`迭代器支持的运算：

| 运算符 | 解释 |
|-----|-----|
| `iter + n` | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n` | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1` |
| `iter1 - iter2` | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器 |

- 只要两个迭代器指向的是同一个容器中的元素或尾元素的下一位置，就能将其相减，所得结果是**difference_type**：保证足够大以存储任何两个迭代器对象间的距离，可正可负，带符号类型。

  ```c++
  vector<int> vec{ 1,2,3 };
  	auto first = vec.begin();
  	auto last = vec.end();
  	std::cout <<  first - last  << " " << last - first;
  	// 输出 -3 3
  ```

  

## 数组

- 相当于vector的低级版，**长度固定**。
- 如果不清楚元素的确切个数，使用`vector`.

### 定义和初始化内置数组

- 初始化：`char input_buffer[buffer_size];`，长度必须是**`const`表达式**，或者不写，让编译器自己推断。
- 数组不允许直接赋值给另一个数组。
- 数组的元素应为对象，不存在引用的数组。

### 理解复杂的数组声明

```c++
int *ptrs[10]; // ptrs 是含有10个整型指针的数组
int &refs[10] = /*  */;   // error:不存在引用的数组
int (*Parray)[10] =&arr;  // Parray 指向一个含有10个整数的数组
int (&arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组
```

- 就数组而言，**由内向外**阅读
- 对于`int (*Parray)[10] =&arr;`，`(*Parray)`表明`Parray`是一个指针。观察右边，可知`Parray`是个指向大小为`10`的数组的指针。观察左边，知道数组中元素是`int`。   即`Parray`是一个指针，指向一个`int`数组，数组中包含10个元素。
- 对于`int (&arrRef)[10] = arr`，`(&arrRef)`表明`arrRef`是一个引用。观察右边，`arrRef`引用一个`10`元素的数组。观察左边，可知数组中的元素是`int`。即`arrRef`是一个引用，引用一个`int`数组，该`int`数组包含`10`个元素。

### 访问数组元素

- 数组下标的类型：`size_t` 。

- 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。

- 与`vector`、`string`一样，当需要遍历数组的所有元素时，最好办法也是使用范围`for`。

- 允许使用数组来初始化`vector`对象。只需要指明拷贝区域的首元素地址和尾后地址，即

  ```c++
  int a[] = {1,2,3,4,5};
  vector<int> v(begin(a), end(a));  // v有5个元素，分别是a中对应元素的副本。
  
  vector<int> v(arr,arr+5);  // 也可以
  ```

  `begin()`、`end()`函数使用形式是将数组作为参数。`begin()`函数返回数组首元素的指针，`end()`函数返回指向尾元素的下一位置的指针。

### 数组和指针

- 使用数组时，编译器一般会把它转换成指针。

- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 

- **指针访问数组**：在表达式中使用数组名时，**数组名会自动转换成指向数组的第一个元素的指针**。

  - 当使用一个数组作为一个`auto`变量的初始值时，推断出来的类型是指针而非数组：

    ```c++
    int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia是一个含有10个整数的数组
    auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素
    // 实际上类似于： auto ia2(&ia[0]); // 显然ia2的类型是int*
    ia2 = 42; // error:ia2是一个指针，不能用int值给指针赋值
    ```

  - 当使用`decltype`关键字时上述转换不会发生

    ```c++
    int ia[] = {0,1,2,3,4,5,6,7,8,9};
    decltype(ia) ia3 = {0,1,2,3,4,5,6};  // decltype(ia)返回的类型是由10int构成的数组
    ia3[4] = 100;  // 0 1 2 3 100 5 6 0 0 0
    ```

- 指针也是迭代器

## C风格字符串

- 从`C`继承来的字符串。

- 用空字符结束（`\0`）。

- 对大多数应用来说，**使用标准库 `string`比使用C风格字符串更安全、更高效**。

- 获取 `string` 中的 `cstring` ：`c_str`成员函数返回值是一个C风格的字符串。即，函数的返回结果是一个指针，该指针，指向一个以空字符结束的字符数组，此数组所存的数据恰好与那个`string`对象的一样。

  ```c++
  string s("Hello world");
  
  char *str = s; // error:不能用string对象初始化char*
  const char *str = s.c_str(); // ok
  
  string a("hello");
  std::cout << strcmp("hello",a); // error
  std::cout << strcmp("hello", a.c_str()); // ok 1
  ```

`C`标准库`String`函数，定义在`<cstring>` 中：

| 函数 | 介绍 |
|-----|-----|
| `strlen(p)` | 返回`p`的长度，空字符不计算在内 |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1` |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1` |

 传入此类函数的指针必须指向以空字符作为结束的数组：

```c++
char ca[] = {'C','+','+'};
cout << strlen(ca) << endl; //error:ca没有以空字符结束
```

**尽量使用vector和迭代器，少用数组**

## 多维数组

- 多维数组 ： 其实是**数组的数组**

- 一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）大小              **由内往外**读

  `int a[3][4] // 大小为3的数组，每个元素都是含有4个整数的数组`

  通常把第一个维度称为**行**，第二个维度称为**列**。

- **多维数组的初始化**： `int ia[3][4] = {{0,1,2,3}, ...}`。

- 使用嵌套的`for`循环处理多维数组的元素。

- 使用**范围for(range for)**语句处理多维数组时时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型。如果不采用引用，程序将第一个循环变量初始化为该数组内首元素的指针（`p114`）

- 多维数组的名字也会转化为指向数组首元素的指针。由于多维数组实际上是数组的数组，所以数组名转换得来的指针实际上是**指向第一个内层数组的指针**

  ```c++
  int a[3][4];
  int (*p)[4] = a;  // p指向a的首元素
  p = &a[2];    // p指向a的尾元素
  ```

- ```c++
  int ia[3][4];             // 数组ia各个元素值为其索引
  	size_t cnt = 0;
  	for (auto &row : ia) {        // 注意外层的引用类型，如果不适用引用类型，将row类型解释成int *,导致内层for不合法
  		for (auto &col : row) {
  			col = cnt;
  			cnt++;
  		}
  	}
  
  // show   version1
  for (auto p = ia; p != ia + 3; p++) {       // p指向含有四个整数的数组
  		for (auto q = *p; q != *p + 4; q++) {   // (*p)是一个含有四个整数的数组，即自动转换成指向首元素的指针
  			cout << *q << " ";                    // q指向4个整数数组的首元素，或者说q指向整数。 
  		}
  		cout << endl;
  	}
  	
  // show version2
  
  for (auto p = begin(ia); p != end(ia); p++) {      //   使用了begin()   end()
  		for (auto q = begin(*p); q != end(*p); q++) {
  			cout << *q << " ";
  		}
  		cout << endl;
  	}
  
  // show version3
  //使用类型别名
  using int_array = int[4];   // // 程序将类型“4个整数组成的数组”命名为int_array
  typedef int int_array[4];  // 等价于上句
  	for (int_array *p = ia; p != ia + 3;p++) {
  		for (int *q = *p; q != *p + 4; q++) {
  			cout << *q << " ";
  		}
  		cout << endl;
  	}
  
  
  ```

  

## 指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

## 指向指针的指针

- 定义： `int **ppi = &pi;`
- 解引用：`**ppi`

## 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。





