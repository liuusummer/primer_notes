# 第十八章 用于大型程序的工具

大规模应用程序的特殊要求包括：

- 在独立开发的子系统之间协同处理错误的能力。
- 使用各种库进行协同开发的能力。
- 对比较复杂的应用概念建模的能力。

## 异常处理

**异常处理**（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并作出相应的处理。

### 抛出异常

在C++语言中，我们通过**抛出**（throwing）一条表达式来**引发**（raised）一个异常。异常类型和当前的调用链决定了哪段**处理代码**（handler）将用来处理该异常。

程序的控制权从`throw`转移到`catch`模块。

**栈展开**：当`throw`出现在一个`try语句块`时，检查该`try语句块`相关的`catch`字句，若有匹配则处理；若无匹配，则继续检查外层的`try`匹配的`catch`。

若一个异常没有被捕获，则它将终止当前的程序。

对象销毁：

- 块退出后，它的局部对象将被销毁。
- 若异常发生在构造函数中，即使某个对象只构造了一部分，也要确保已构造的成员正确地被销毁。
- 将资源释放放在类的析构函数中，以保证资源能被正确释放。析构函数本身不会引发异常。

### 捕获异常

若无需访问抛出的异常对象，则可以忽略捕获形参的名字。

通常，若`catch`接受的异常与某个继承体系有关，则最好将该`catch`的参数定义成引用类型。

搜索`catch`未必是最佳匹配，而是第一个匹配，因此，越细化的`catch`越应该放在`catch`列表前段。

重新抛出：`catch`代码执行一条`throw;`将异常传递给另一个`catch`语句。

捕获所有异常：`catch(...)`

### 构造函数

处理构造函数初始值异常的唯一方法是将构造函数协程函数`try`语句块。

示例：

```cpp
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try: 
    data(std::make_shared<std::vector<T> >(il){
        /*函数体*/
    } catch(const std::bad_alloc &e){ handle_out_of_memory(e); }
```

### noexcept异常说明

使用`noexcept`说明指定某个函数不会抛出异常。

示例：

```cpp
void recoup(int) noexcept; //C++11
coid recoup(int) throw(); //老版本
```

### 异常类层次

标准exception层次：

- exception
  - bad_cast
  - bad_alloc
  - runtime_error
    - overflow_error
    - underflow_error
    - range_error
  - logic_error
    - domain_error
    - invalid_argument
    - out_of_range
    - length_error

自定义异常类：

示例：

```cpp
class out_of_stock: public std::runtime_error {
    explicit out_of_stock(const std::string &s):
    std::runtime_error(s){ }
};
```

## 命名空间

大型应用程序通常会使用多个独立开发的库，其中某些名字可能会相互冲突。多个库将名字放置在全局命名空间中将引发**命名空间污染**（namespace pollution）。**命名空间**（namespace）分割了全局命名空间，其中每个命名空间是一个作用域。

### 命名空间定义

- 命名空间的定义包含两部分：1.关键字`namespace`；2.命名空间名称。后面是一系列由花括号括起来的声明和定义。命名空间作用域后面无需分号。能出现在全局作用域中的声明就也能出现在命名空间中。

示例：

```cpp
namespace cplusplus_primer
{
    class Sales_data { / * ... * /};
    Sales_data operator+(const Sales_data&, const Sales_data&);
    class Query { /* ... */ };
    class Query_base { /* ... */};
}   // 命名空间结束后无须分号，这一点与块类似
```

- 命名空间作用域后面不需要分号结束。
- 和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。

- 每个命名空间都是一个**作用域**。定义在某个命名空间内的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌套作用域中的任何单位访问。位于该命名空间之外的代码必须明确指出所用的名字是属于哪个命名空间的。

  ```c++
  cplusplus_primer::Query q = cplusplus_primer::Query("hello");
  ```

- 命名空间可以是**不连续**的。这点不同于其他作用域，意味着同一命名空间可以在多处出现。

  ```c++
  namespace nsp
  {
      // 相关声明
  }
  ```

  如果之前没有名为*nsp*的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加新的成员声明。

  利用命名空间不连续的特性可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似管理自定义类和函数的方式。

  - 命名空间的一部分成员用于定义类，以及声明作为类接口的函数和对象。这些成员应该放置在头文件中。
  - 命名空间成员的定义部分放置在另外的源文件中。源文件需要包含对应的头文件。

  程序中的某些实体只能定义一次，如非内联函数、静态数据成员等，命名空间中定义的名字也需要满足该要求。

- 定义本书的命名空间：

  - 通过接口与实现分离的机制，可以将`cplusplus_primer`库定义在几个不同的文件中。`Sales_data`类的声明及其函数将置于`Salas_data.h`头文件中；`Query`类将置于`Query.h`头文件中，对应的实现文件分别是`Sales_data.cc`和`Query.cc`:

    ```c++
    // ---- Sales_data.h----
    // #includes 应该出现在打开命名空间的操作之前
    # include <string>
    namespace cplusplus_primer
    {
        class Sales_data { /* ... */};
        Sales_data operator+(const Sales_data&, const Sales_data&);
        // Sales_data的其他接口函数的声明
    }
    
    // ---- Sales_data.cc----
    // 确保 #includes 出现在打开命名空间的操作之前
    # include "Sales_data.h"
    namespace cplusplus_primer
    {
        // Sales_data成员及重载运算符的定义
    }
    ```

  - 程序如果想使用我们定义的库，必须包含必要的文件。这些头文件的名字定义在命名空间`cplusplus_primer`内：

    ```c++
    // -----user.cc----
    // Sales_data.h头文件的名字位于命名空间cplusplus_primer中
    #include "Sales_data"
    int main(){
        using namespace cplusplus_primer;
        Sales_data trans1,trans2;
        // ....
        return 0;
    }
    ```

  - 通常情况下，`#include`不应该出现在命名空间内部。否则头文件中的所有名字都会被定义为该命名空间的成员。

  - 定义多个类型不相关的命名空间时应该使用单独的文件分别表示每个类型。

- **定义命名空间**

  - 可以在命名空间的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。

    ```c++
    // 命名空间之外定义的成员必须使用含有前缀的名字
    cplusplus_primer::Sales_data
    cplusplus_primer::operator+(const Sales_data& lhs, const Sales_data& rhs)
    {
        Sales_data ret(lhs);
        // ...
    }
    ```

- **模板特例化**

  模板特例化必须定义在原始模板所属的命名空间中。可以在命名空间内部添加模板特例化声明，而在外部对其进行定义。

  ```c++
  // 我们必须将模板特例化声明成std的成员
  namespace std
  {
      template <> struct hash<Sales_data>;
  }
  
  // 在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了
  template <> struct std::hash<Sales_data>
  {
      size_t operator()(const Sales_data& s) const
      {
          return hash<string>()(s.bookNo) ^
              hash<unsigned>()(s.units_sold) ^
              hash<double>()(s.revenue);
      }
      // other members as before
  };
  ```

- **全局命名空间**

  - 全局作用域中的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在**全局命名空间(global namespace)**中。

  - 全局命名空间以隐式方式声明，在所有程序中都存在。

  - 全局作用域中定义的名字被隐式添加到全局命名空间（global namespace）中。

  - 作用域运算符`::`可以用于全局命名空间的成员。因为全局命名空间是隐式声明的，所以它并没有名字。

    ```c++
    ::member_name    // 表示全局命名空间中的一个成员
    ```

- **嵌套的命名空间**

  - 嵌套的命名空间是指定义在其他命名空间中的命名空间：

    ```c++
    namespace cplusplus_primer{
        // 第一个嵌套的命名空间：定义了库的Query部分
        namespace Query{
            class Query{ /*...*/ };
            Query operato&(const Query&,const Query&);
            // ...
        }
        // 第二个嵌套的命名空间：定义了库的Sales_data部分
        namespace Bookstore{
            class Quote{ /*...*/};
            class Disc_quote:public Quote{/*...*/};
            // ...
        }
    }
    ```

  - 命名空间可以嵌套。嵌套的命名空间同时也是一个嵌套的作用域，它嵌套在外层命名空间的作用域内。内层命名空间声明的名字会隐藏外层命名空间的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码在访问时需要在名字前添加限定符。

- **内联命名空间**（C++11）：

  - C++11新增了内联命名空间（inline namespace）。和一般的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。定义内联命名空间的方式是在`namespace`前添加关键字`inline`。`inline`必须出现在该命名空间第一次定义的地方。后续再打开命名空间时候可以写`inline`也可以不写。

    ```c++
    inline namespace FifthEd{
        // 该命名空间表示本书第五版的代码
    }
    namespace FifthEd{    // 隐式内联
        class Query_base{/*...*/}
        // 其他与Query有关的声明
    }
    ```

  - 当应用程序的代码在两次发布之间发生了改变时，通常会使用内联命名空间。

    ```c++
    namespace FourthEd
    {
        class Item_base { /* ... */};
        class Query_base { /* ... */};
        // other code from the Fourth Edition
    }
    
    namespace cplusplus_primer
    {
        #include "FifthEd.h"
        #include "FourthEd.h"
    }
    ```

    因为*FifthEd*是内联的，所以形如`cplusplus_primer::`的代码可以直接获得*FifthEd*的成员。如果想使用早期版本，则必须加上完整的外层命名空间名字。

- **未命名的命名空间**：

  - 未命名的命名空间（unnamed namespace）指关键字`namespace`后紧跟以花括号包围的一系列声明语句。未命名的命名空间中定义的变量拥有**静态生命周期**：它们在第一次使用前创建，直到程序结束才销毁。

  - 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字在每个包含该头文件的文件中对应不同实体。

  - 定义在未命名的命名空间中的名字可以直接使用，不能对其使用作用域运算符。

  - 定义在未命名的命名空间中的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在最外层作用域中，则该命名空间中的名字必须要与全局作用域中的名字有所区别。

    ```c++
    int i; // i的全局声明
    namespace
    {
        int i;
    }
    // 二义性：i的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中
    i = 10;
    
    namespace local
    {
        namespace
        {
            int i;
        }
    }
    // ok: 定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同。
    local::i = 42;
    ```

  - 在标准C++引入命名空间的概念之前，程序需要将名字声明为`static`的以令其对整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为`static`的全局实体在其所在的文件之外不可见。该做法已经被C++标准取消，现在应该使用未命名的命名空间。

### 使用命名空间成员

- 像`namespace_name::member_name`这样使用命名空间的成员非常繁琐。

- 可以通过一些简便的方法使用命名空间的成员：

  - **命名空间的别名(namespace alias)**

    - 可以使用关键字`namespace`和`=`为命名空间定义别名（namespace alias）。别名必须出现在命名空间的定义之后。

    ```c++
    namespace primer = cplusplus_primer;
    ```

    - 一个命名空间可以有多个别名，它们都与命名空间的原名等价。

  - **using声明(using declaration):扼要概述**：

    - 一条`using`声明（using declaration）一次只引入命名空间的一个成员。
    - `using`声明的有效范围从`using`声明语句开始，一直到`using`声明所在的作用域结束为止。在此过程中，外层作用域的同名实体会被隐藏。未加限定的名字只能在`using`声明所在的作用域及其内层作用域中使用。
    - `using`声明可以出现在全局作用域、局部作用域、命名空间作用域和类的作用域中。在类的作用域中使用时，`using`声明只能指向基类成员。

  - **using指示(using directive)**：

    - 和`using`声明不同，`using`指示使某个命名空间中的所有名字都可见。

    - `using`指示以关键字`using`开始，后面是关键字`namespace`以及命名空间的名字。

      ```c++
      using namespace std;
      
      string s = "hello";
      ```

    - `using`指示可以出现在全局作用域、局部作用域和命名空间作用域中，不能出现在类的作用域中。

    - 如果对*std*等命名空间使用了`using`指示而未做任何特殊控制的话，会重新引入多个库之间的名字冲突问题。

    -  `using`指示具有将命名空间成员提升到包含命名空间本身和`using`指示的最近外层作用域的能力。

      ```c++
      // 命名空间A和函数f定义在全局作用域中
      namespace A
      {
          int i, j;
      }
      
      void f()
      {
          using namespace A;  // 把A中的名字注入到全局作用域中
          cout << i * j << endl;  // 使用命名空间A中的i和j
          // ...
      }
      ```

    - 当命名空间被注入到其外层作用域之后，该命名空间中定义的名字可能会与其外层作用域的成员冲突。这种冲突允许存在，但是要想使用冲突的名字，就必须明确指出名字的版本。

      ```c++
      namespace blip
      {
          int i = 16, j = 15, k = 23;
          // other declarations
      }
      int j = 0;  // ok: j inside blip is hidden inside a namespace
      
      void manip()
      {
          // using directive; the names in blip are ''added'' to the global scope
          using namespace blip;   // 如果使用了j，则将在::j 和 blip::j之间产生冲突
          ++i;    // sets blip::i to 17
          ++j;    // error ambiguous: global j or blip::j?
          ++::j;  // ok: sets global j to 1
          ++blip::j;    // ok: sets blip::j to 16
          int k = 97;   // 当前局部的 k 隐藏了 blip::k
          ++k;    // sets local k to 98
      }
      ```

  - 头文件如果在其顶层作用域中使用`using`声明或`using`指示，则会将名字注入到包含该头文件的所有文件中。通常，头文件只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用`using`声明或`using`指示。

  - 相比于使用`using`指示，在程序中对命名空间中的每个成员分别使用`using`声明效果更好。

    - 如果程序使用了多个不同的库，而这些库中的名字通过`using`指示变得可见，则全局命名空间污染问题将重新出现。
    - `using`指示引发的二义性错误只有在使用了冲突名字的地方才会被发现。而`using`声明引发的二义性错误在声明处就能发现。

    建议在命名空间本身的实现文件中使用`using`指示。

### 类、命名空间与作用域

```cpp
namespace A{
    class C1{
        public:
            int f3();
    }
}

A::C1::f3
```

### 重载与命名空间

`using`声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。

## 多重继承与虚继承

### 多重继承

### 类型转换与多个基类

### 多重继承下的类作用域

* 当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。

### 虚继承

* 虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象成为**虚基类**。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
* 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。

### 构造函数与虚继承

* h含有虚基类的对象的构造顺序与一般的顺序稍有**区别**：首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序对其进行初始化。
* 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。